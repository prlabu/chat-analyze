Project structure

Message
 |datetime: Datetime
 |sender: Participant
 |original_text: str
 |sensored_text: str
 |attachments: str
 |chat: Chat
 |msg_number: int
 |ID: chat.name + msg_number


 Participant
 |name_in_chat: str
 |ID: str
 |pseudonym: str
 |phone: str
 |chat: Chat
 |gender: str
 |age: str
 |ethnicity: str


Chat
 |ID: str
 |messages: Message[]
 |participants: Participant{}
 |meta: str
 anonymize()
 replace_string(a:str, b:str)
 to_csv(filename: str)
 to_json(filename:str)
 find_all_links()
 find_all_phones()



Notes: 
Messages from WhatsApp are currently considered valid messages, with sender=WhatsApp
It is assumed that only one type of format is present within one text file. 
Phone numbers can be very hard to find, so the user validates each one individually. For example, the list of 2018s look very much like phone numbers to a computer. For now, we are only matching phone numbers that look like @6583827520, which are generated by WhatsApp. 
At first, I was honestly making it too difficult on myself by trying to make it very generalized. But with such a range of data, it simply can't be all-encompassing. 
- I split up the text files such that a single file contains only the WhatsApp messages. It should contain no metadata at all. I did my best to split up the files but it's very possible that I missed the splitting of one. If this is the case, there will be a very long message somewhere in the database.

The standard progresssion is: 
call parse chat, specifying with text file you want to parse along with its format
have the option to add user details (pseudonym, age, etc)
find all phone numbers
find all links




TODO:
check for WhatsApp meta msgs
make sure dateutil is parsing dates correctly, 12hr vs 24hr
preprocessing - make sure no [] in the chat besides the assumed ones
README




HOURS: 
15 March : 2-6, 7-10
18 April : 9-1 pm
27 April: 7:30pm - 10:30pm
29 April: 11:30am - 2pm, 12:30-2am
7 May: 10:15am - 1:45pm


